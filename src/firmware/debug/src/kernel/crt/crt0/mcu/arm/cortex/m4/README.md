# ARM Cortex M4* Implementation Details

## Interrupts
Microcontrollers based on ARM M4* profiles have a set of 15 common, MCU-agnostic interrupts that have been defined by ARM, as well as peripheral interrupts that are MCU- and manufacturer-specific.  The vector table for all of the ARM interrupts is in `IsrVectorTable.cc`; there will be a corresponding table of peripheral interrupts provided by each of the specific M4*-based implementations.  It is the job of the linker script to merge both tables.

There are two types of ISRs - 'Naked' and 'Per-Core':
- A naked ISR is the only type that can be placed into the vector table and consists of a `static` handler that is not allowed to take any dependencies; it is not associated with any object instance and has no associated overhead.  For ARM, such ISRs do not need to be decorated with the `[[gnu::interrupt]]` attribute as the hardware implements the AAPCS, but `[[gnu::general_regs_only]]` might be required to prevent the register allocator clobbering unpushed VFP registers.
- A per-core ISR incurs a little overhead but is more flexible in that there is one object instance for state and encapsulation per CPU core; this instance can also have API dependencies injected into it during boot.  Per-core ISRs are transparently adapted from a naked ISR that can be placed into the vector table and which handles the object instance lookup and method dispatch based on which core is servicing the interrupt.  This adapter is the platform-independent `kernel::drivers::NakedToPerCoreIsrAdapter`, which is the target of the ARM-specific `NakedToPerCoreIsrTrampoline` used for the vector table entry.

Interrupt Service Routines (ISRs) are provided by Drivers, typically the MCU-specific parts but not necessarily, and are wired into the vector table based on the value of their configured `irq` (`static constexpr`) member.  Only drivers that are required / in-use will have their ISRs placed into the vector table.  There are two default implementations provided, `UnhandledIsr` and `ReservedIsr`, that are placed into the vector table if there is none provided by a driver for the given IRQ.

There is one special, non-driver, non-unhandled, non-reserved ISR handler for ARM Cortex M4* implementations, which is the `_resetHandler`.  This is the entrypoint after reset and is provided by each of the MCU-specific implementations.

## Syscalls
Kernel 'syscalls' are implemented with the `svc` opcode, which in turn is handled by Interrupt Service Routine (ISR) with IRQ 11 (vector 10).  An implementation of this ISR is provided by the `syscall` driver found in `kernel/drivers/kernel/syscall`, along with MCU-agnostic APIs to abstract the details from other drivers.  The 8-bit operand to the `svc` opcode is unused at this time and set to `0x00`; the only way to use it from within the ISR is by reading and parsing the opcode at runtime meaning it is of limited utility due to the inefficiency and complexity.  Instead, register `r1` is used for the purpose of identifying the required operation.

Register `r1` contains the ID of the system call - `r7` is the defacto standard for ARM-based processors due to various historical factors, instruction encoding and ABI compatibility, but `r1` works slightly better for us as all syscall handlers for ARM always take exactly two arguments.  The ISR will use `r1` to look up and dispatch to an appropriate handler.  The number itself is simply an implementation detail of the ARM mechanism, used only as a unique token for identifying what operation the caller has requested.  It is determined at compile-time from the registered syscall handlers and not used by the kernel iteself.  As such, do not rely on this number being any particular value or even constant across compilations, which is why it needs to be determined via the `TSyscallFor<T>::id` template parameter.

A syscall always has one parameter, which is a pointer to a data structure somewhere in the Task's address space.  This structure can be either `const` or non-`const` depending on the requirements of the handler.  The argument is stored in register `r0` which fits nicely with the ARM ABI of `this` or the first argument, and so the optimiser / register allocator should be able to utilise this nicely.

The above mechanism for invoking syscalls (ie. adapting the kernel 'syscall' concept to the ARM `svc` opcode) is encapsulated by the `SyscallPrimitive` class, in turn used directly by the public `SyscallApi`.
